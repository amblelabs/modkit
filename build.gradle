plugins {
    id "fabric-loom" version "1.9-SNAPSHOT"
    id "maven-publish"
    id "java"
}

apply from: 'versioning.gradle'

version = getCurrentVersion()
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

repositories {
    exclusiveContent {
        forRepository {
            maven {
                name = "Modrinth"
                url = "https://api.modrinth.com/maven"
            }
        }
        filter {
            includeGroup "maven.modrinth"
        }
    }
    // Scheduler, Queue, MultiDim, AutoJSON
    maven { url "https://theo.is-a.dev/maven/" }
}

loom {
    accessWidenerPath = file("src/main/resources/${project.mod_id}.accesswidener")

    runs {
        // This adds a new gradle task that runs the datagen API
        datagen {
            inherit server
            name "Data Generation"
            vmArg "-Dfabric-api.datagen"
            vmArg "-Dfabric-api.datagen.output-dir=${file("src/main/generated")}"
            vmArg "-Dfabric-api.datagen.modid=${project.mod_id}"

            runDir "build/datagen"
        }

	    testmodClient {
		    client()
		    ideConfigGenerated project.rootProject == project
		    name = "Testmod Client"
		    source sourceSets.test
	    }
	    testmodServer {
		    server()
		    ideConfigGenerated project.rootProject == project
		    name = "Testmod Server"
		    source sourceSets.test
	    }
    }
}

// Add the generated resources to the main source set
sourceSets {
    main {
        resources {
            srcDirs += [
                    "src/main/generated"
            ]
        }
    }

	test {
		runtimeClasspath += main.runtimeClasspath
		compileClasspath += main.compileClasspath
	}
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    include(implementation "net.objecthunter:exp4j:0.4.8")

    include(modApi("dev.drtheo:multidim:${project.multidim_version}"))
    include(modApi("dev.drtheo:scheduler:${project.scheduler_version}"))
    include(modApi("dev.drtheo:queue:${project.queue_version}"))

	// getter setter
	compileOnly 'org.projectlombok:lombok:1.18.34'
	annotationProcessor 'org.projectlombok:lombok:1.18.34'
	testCompileOnly 'org.projectlombok:lombok:1.18.34'
	testAnnotationProcessor 'org.projectlombok:lombok:1.18.34'
}

processResources {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE // Exclude duplicate files, I don"t why this even works
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "loader_version", project.loader_version

	exclude '.cache'

	def expansionVars = [
			"version": project.version,
            "minecraft_version": project.minecraft_version,
            "loader_version": project.loader_version
	]

    filesMatching("fabric.mod.json") {
        expand expansionVars
    }
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 17
}

java {
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_22
	targetCompatibility = JavaVersion.VERSION_17
}

jar {
    inputs.property "archivesName", project.base.archivesName

	// needed because inputs.properties.archivesName is not accessible configuration time
	def archivesNameValue = project.base.archivesName

	from("LICENSE") {
		rename { "${it}_${archivesNameValue.get()}" }
	}
}

publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	repositories {
		maven {
			name = "ci"
			url = providers.environmentVariable("CI_MAVEN_PATH")
		}
	}
}
